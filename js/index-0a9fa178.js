import{_ as e,d as n,q as t,o as i,a as o,b as a,z as r,B as s,H as l,I as u}from"./vendors-ac8af1c3.js";function c(e){if(e){var n=Cesium.Ellipsoid.WGS84.cartesianToCartographic(e);return{lng:Cesium.Math.toDegrees(n.longitude),lat:Cesium.Math.toDegrees(n.latitude),alt:n.height}}}function m(e,n){return e?Cesium.Cartesian3.fromDegrees(e.lng||e.lon,e.lat,e.alt=n||e.alt,Cesium.Ellipsoid.WGS84):Cesium.Cartesian3.ZERO}function C(e){if(e&&e.get&&e&&e.get)return"uniform sampler2D colorTexture;\n                uniform sampler2D depthTexture;\n                varying vec2 v_textureCoordinates;\n                uniform vec4 u_scanCenterEC;\n                uniform vec3 u_scanPlaneNormalEC;\n                uniform float u_radius;\n                uniform vec4 u_scanColor;\n                \n                vec4 toEye(in vec2 uv, in float depth){\n                  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n                  vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n                  posInCamera =posInCamera / posInCamera.w;\n                  return posInCamera;\n                }\n                \n                vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\n                    vec3 v01 = point - planeOrigin;\n                    float d = dot(planeNormal, v01) ;\n                    return (point - planeNormal * d);\n                }\n                \n                float getDepth(in vec4 depth){\n                    float z_window = czm_unpackDepth(depth);\n                    z_window = czm_reverseLogDepth(z_window);\n                    float n_range = czm_depthRange.near;\n                    float f_range = czm_depthRange.far;\n                    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n                }\n                \n                void main(){\n                    gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n                    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\n                    vec4 viewPos = toEye(v_textureCoordinates, depth);\n                    vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n                    float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n                    if(dis < u_radius){\n                      float f = 1.0 - abs(u_radius - dis) / u_radius;\n                      f = pow(f, float("+e.border+"));\n                      gl_FragColor = mix(gl_FragColor, u_scanColor, f);\n                    }\n                  }\n                  "}function d(e){if(e&&e.get)return"uniform sampler2D colorTexture;\n                uniform sampler2D depthTexture;\n                varying vec2 v_textureCoordinates;\n                uniform vec4 u_scanCenterEC;\n                uniform vec3 u_scanPlaneNormalEC;\n                uniform vec3 u_scanLineNormalEC;\n                uniform float u_radius;\n                uniform vec4 u_scanColor;\n                \n                vec4 toEye(in vec2 uv, in float depth){\n                vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n                vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n                posInCamera =posInCamera / posInCamera.w;\n                return posInCamera;\n                }\n                \n                bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt){\n                vec3 v01 = testPt - ptOnLine;\n                normalize(v01);\n                vec3 temp = cross(v01, lineNormal);\n                float d = dot(temp, u_scanPlaneNormalEC);\n                return d > 0.5;\n                }\n                \n                vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\n                vec3 v01 = point -planeOrigin;\n                float d = dot(planeNormal, v01) ;\n                return (point - planeNormal * d);\n                }\n                \n                float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt){\n                vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\n                return length(tempPt - ptOnLine);\n                }\n                \n                float getDepth(in vec4 depth){\n                float z_window = czm_unpackDepth(depth);\n                z_window = czm_reverseLogDepth(z_window);\n                float n_range = czm_depthRange.near;\n                float f_range = czm_depthRange.far;\n                return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n                }\n                \n                void main(){\n                gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n                float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n                vec4 viewPos = toEye(v_textureCoordinates, depth);\n                vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n                float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n                float twou_radius = u_radius * 2.0;\n                if(dis < u_radius){\n                    float f0 = 1.0 -abs(u_radius - dis) / u_radius;\n                    f0 = pow(f0, 64.0);\n                    vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\n                    float f = 0.0;\n                    if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz)){\n                        float dis1= length(prjOnPlane.xyz - lineEndPt);\n                        f = abs(twou_radius -dis1) / twou_radius;\n                        f = pow(f, float("+e.width+"));\n                    }\n                    if(float("+e.border+") > 0.0){\n                        gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\n                    } else {\n                        gl_FragColor = mix(gl_FragColor, u_scanColor, f);\n                    }\n                    }\n                }\n                "}let v,f;function p(e,n){f&&e.scene.postProcessStages.remove(f)}const g={class:"Cesuim",id:"cesiumContainer"},x={class:"content"};var _=e(n({__name:"index",setup(e){let n,_,w={weather:!1,effect:!1,model:!1};function y(){p(v),v.entities.removeAll(),v.dataSources.removeAll(),v.scene.postProcessStages.remove(n),v.scene.postProcessStages.remove(_)}function h(){var e,n;w.weather&&p(v),w.weather=!0,(e=v)&&(f=e.scene.postProcessStages.add(new Cesium.PostProcessStage({name:n||"rain",fragmentShader:"uniform sampler2D colorTexture;\n  varying vec2 v_textureCoordinates;\n  \n  float hash(float x){\n  return fract(sin(x*23.3)*13.13);\n  }\n  \n  void main(){\n      float time = czm_frameNumber / 60.0;\n      vec2 resolution = czm_viewport.zw;\n      vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n      vec3 c=vec3(.6,.7,.8);\n      float a=-.4;\n      float si=sin(a),co=cos(a);\n      uv*=mat2(co,-si,si,co);\n      uv*=length(uv+vec2(0,4.9))*.3+1.;\n      float v=1.-sin(hash(floor(uv.x*100.))*2.);\n      float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\n      c*=v*b;\n      gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c, 1), 0.2);\n  }\n  "})))}function P(){var e,n;w.weather&&p(v),w.weather=!0,(e=v)&&(f=e.scene.postProcessStages.add(new Cesium.PostProcessStage({name:n||"snow",fragmentShader:"uniform sampler2D colorTexture;\n      varying vec2 v_textureCoordinates;\n      \n      float snow(vec2 uv,float scale){\n          float time = czm_frameNumber / 60.0;\n          float w=smoothstep(1.,0.,-uv.y*(scale/10.));\n          if(w<.1)return 0.;\n          uv+=time/scale;\n          uv.y+=time*2./scale;\n          uv.x+=sin(uv.y+time*.5)/scale;\n          uv*=scale;\n          vec2 s=floor(uv),f=fract(uv),p;\n          float k=3.,d;\n          p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;\n          d=length(p);\n          k=min(d,k);\n          k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n          return k*w;\n      }\n      \n      void main(){\n          vec2 resolution = czm_viewport.zw;\n          vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n          vec3 finalColor=vec3(0);\n          float c = 0.0;\n          c+=snow(uv,30.)*.0;\n          c+=snow(uv,20.)*.0;\n          c+=snow(uv,15.)*.0;\n          c+=snow(uv,10.);\n          c+=snow(uv,8.);\n          c+=snow(uv,6.);\n          c+=snow(uv,5.);\n          finalColor=(vec3(c));\n          gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.3);\n          \n      }\n      "})))}function z(){w.effect&&v.entities.removeAll(),w.effect=!0;const e={id:"1",position:Cesium.Cartesian3.fromDegrees(104.5,30.5),point:{show:!0,color:Cesium.Color.SKYBLUE,pixelSize:10,outlineColor:Cesium.Color.YELLOW,outlineWidth:3,verticalOrigin:Cesium.VerticalOrigin.TOP}};v.entities.add(e);const t={id:(new Date).getTime(),position:Cesium.Cartesian3.fromDegrees(104.5,30.5,1e4),color:Cesium.Color.RED,duration:5e3,border:10,radius:20,circleMode:"CircleScan"};n||(n=function(e){var n;const t=e.id,i=e.position,o=i,a=new Cesium.Cartesian4(o.x,o.y,o.z,1),r=c(i),s=m({lng:r.lng,lat:r.lat,alt:r.alt+500}),l=new Cesium.Cartesian4(s.x,s.y,s.z,1),u=(new Date).getTime(),d=new Cesium.PostProcessStage({name:t,fragmentShader:null!=(n=C({get:!0,border:e.border}))?n:"",uniforms:{u_scanCenterEC:()=>Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,a,new Cesium.Cartesian4),u_scanPlaneNormalEC:()=>{const e=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,a,new Cesium.Cartesian4),n=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,l,new Cesium.Cartesian4),t=new Cesium.Cartesian3;return t.x=n.x-e.x,t.y=n.y-e.y,t.z=n.z-e.z,Cesium.Cartesian3.normalize(t,t),t},u_radius:()=>"CircleScan"==e.circleMode?e.radius*(((new Date).getTime()-u)%e.duration)/e.duration:e.radius,u_scanColor:e.color}});return v.scene.postProcessStages.add(d),d}(t)),v.flyTo(v.entities.getById("1"))}function D(){w.effect&&v.entities.removeAll(),w.effect=!0;const e={id:"2",position:Cesium.Cartesian3.fromDegrees(114.5,30.5),point:{show:!0,color:Cesium.Color.SKYBLUE,pixelSize:10,outlineColor:Cesium.Color.YELLOW,outlineWidth:3,verticalOrigin:Cesium.VerticalOrigin.TOP}};v.entities.add(e),v.flyTo(v.entities.getById("2"));const n={id:(new Date).getTime(),position:Cesium.Cartesian3.fromDegrees(114.5,30.5,1e4),color:Cesium.Color.RED,duration:5e3,border:10,radius:20,circleMode:"CircleScan"};_||(_=function(e){var n,t;if(e&&e.position){const i=e.id,o=e.position,a=e.duration,r=e.border,s=null!=(n=e.width)?n:10,l=e.radius,u=e.color,C=o,f=new Cesium.Cartesian4(C.x,C.y,C.z,1),p=c(o),g=m({lng:p.lng,lat:p.lat,alt:p.alt+500}),x=new Cesium.Cartesian4(g.x,g.y,g.z,1),_=m({lng:p.lng+.001,lat:p.lat,alt:p.alt}),w=new Cesium.Cartesian4(_.x,_.y,_.z,1),y=(new Date).getTime(),h=new Cesium.Quaternion,P=new Cesium.Matrix3,z=new Cesium.Cartesian4,D=new Cesium.Cartesian4,E=new Cesium.Cartesian4,O=new Cesium.Cartesian3,T=new Cesium.Cartesian3,S=new Cesium.PostProcessStage({name:i,fragmentShader:null!=(t=d({border:r,width:s,get:!0}))?t:"",uniforms:{u_scanCenterEC:function(){return Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,f,z)},u_scanPlaneNormalEC:function(){const e=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,f,z),n=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,x,D);return O.x=n.x-e.x,O.y=n.y-e.y,O.z=n.z-e.z,Cesium.Cartesian3.normalize(O,O),O},u_scanLineNormalEC:function(){const e=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,f,z),n=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,x,D),t=Cesium.Matrix4.multiplyByVector(v.camera.viewMatrix,w,E);O.x=n.x-e.x,O.y=n.y-e.y,O.z=n.z-e.z,Cesium.Cartesian3.normalize(O,O),T.x=t.x-e.x,T.y=t.y-e.y,T.z=t.z-e.z;const i=((new Date).getTime()-y)%a/a;return Cesium.Quaternion.fromAxisAngle(O,i*Cesium.Math.PI*2,h),Cesium.Matrix3.fromQuaternion(h,P),Cesium.Matrix3.multiplyByVector(P,T,T),Cesium.Cartesian3.normalize(T,T),T},u_radius:l,u_scanColor:u}});return v.scene.postProcessStages.add(S),S}}(n))}function E(){w.model&&(v.entities.removeAll(),v.dataSources.removeAll()),w.model=!0;!function(e){let n=new Cesium.CustomDataSource("enetiestestdata");v.dataSources.add(n),n.entities.add({name:"line",polyline:{positions:Cesium.Cartesian3.fromDegreesArrayHeights(e.flat()),material:Cesium.Color.RED,width:1}});let t,i,o=new Cesium.SampledPositionProperty,a=new Date,r=a.getTime();e.forEach(((e,n)=>{let i=new Date(r+5e3*n);t=i;let a=Cesium.Cartesian3.fromDegrees(e[0],e[1],e[2]);o.addSample(Cesium.JulianDate.fromDate(i),a)})),o.setInterpolationOptions({interpolationDegree:1e-4,interpolationAlgorithm:Cesium.LagrangePolynomialApproximation}),i=n.entities.add({availability:new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({start:Cesium.JulianDate.fromDate(a),stop:Cesium.JulianDate.fromDate(new Date(t))})]),position:o,orientation:new Cesium.VelocityOrientationProperty(o),label:{text:"",fillColor:Cesium.Color.RED,pixelOffset:new Cesium.Cartesian2(0,-30)},model:{uri:"/model/xiaofangche.gltf",scale:1,minimumPixelSize:70,maximumScale:70},path:{leadTime:0,resolution:1,material:new Cesium.PolylineGlowMaterialProperty({glowPower:.1,color:Cesium.Color.GREEN}),width:10}}),v.clock.onTick.addEventListener((e=>{i.position.getValue(e.currentTime);let n=Cesium.Ellipsoid.WGS84.cartesianToCartographic(i.position.getValue(e.currentTime));n.longitude=Cesium.Math.toDegrees(n.longitude),n.latitude=Cesium.Math.toDegrees(n.latitude),i.label.text=Number(n.longitude).toFixed(4)+","+Number(n.latitude).toFixed(4)})),v.trackedEntity=i,v.clock.currentTime=Cesium.JulianDate.fromDate(a),v.clock.stopTime=Cesium.JulianDate.fromDate(new Date(t)),v.clock.clockRange=Cesium.ClockRange.LOOP_STOP,v.clock.shouldAnimate=!0}([[117.4603186710001,31.14388249900003,11.147400000001653],[117.45946237800001,31.143739847000063,11.108399999997346],[117.45859906800001,31.143571198000075,10.89079999999376],[117.45789337300005,31.143422075000046,11.12170000000333],[117.4571119630001,31.143350937000037,11.545700000002398],[117.45620292500007,31.143325030000028,11.529899999994086],[117.45545284400009,31.143363754000063,11.038100000005215],[117.45473256600008,31.143448056000068,10.86380000000645],[117.45399052200003,31.143623321000064,11.345600000000559],[117.45347615200001,31.14381135600007,11.687300000005052],[117.45292459000007,31.144031608000034,12.106100000004517],[117.45192097000006,31.144426226000064,12.842399999994086],[117.45065835500009,31.144954275000032,12.712299999999232],[117.44980033200011,31.145266268000057,12.504899999999907],[117.44943370300007,31.145413392000023,12.731599999999162],[117.44920128900003,31.145382554000037,12.967699999993783],[117.44897692800009,31.144980649000047,14.909599999999045],[117.44872415000009,31.14449598400006,14.55899999999383],[117.44851592000009,31.144125416000065,14.410999999992782],[117.44848024700002,31.14392828000007,14.475800000000163],[117.44948683700011,31.14350793500006,14.507400000002235],[117.45089297600009,31.142959855000072,14.290399999998044],[117.45149371900004,31.142693826000027,14.127099999997881],[117.45166848000008,31.142571364000048,15.52610000000277],[117.4516358520001,31.142433625000024,14.0341000000044],[117.45082070700005,31.140899211000033,13.289099999994505],[117.45082070700005,31.140899211000033,13.289099999994505]])}return t((()=>{v=new Cesium.Viewer("cesiumContainer",{geocoder:!1,homeButton:!1,sceneModePicker:!1,baseLayerPicker:!1,navigationHelpButton:!1,animation:!1,timeline:!1,fullscreenButton:!1,vrButton:!1,infoBox:!1}),v.scene.sun.show=!1,v.scene.moon.show=!1,v.scene.skyAtmosphere.show=!1,v.scene.globe.showGroundAtmosphere=!1,v.scene.globe.enableLighting=!0,v.scene.fog.enabled=!1,v.scene.globe.depthTestAgainstTerrain=!0,v.cesiumWidget._creditContainer.style.display="none"})),(e,n)=>{const t=u;return i(),o("div",g,[a("div",x,[r(t,{onClick:P},{default:s((()=>[l("雪天")])),_:1}),r(t,{onClick:h},{default:s((()=>[l("雨天")])),_:1}),r(t,{onClick:z},{default:s((()=>[l("波动")])),_:1}),r(t,{onClick:D},{default:s((()=>[l("扫描")])),_:1}),r(t,{onClick:E},{default:s((()=>[l("模型车")])),_:1}),r(t,{onClick:y},{default:s((()=>[l("清除")])),_:1})])])}}}),[["__scopeId","data-v-3ae3ea03"]]);export{_ as default};
